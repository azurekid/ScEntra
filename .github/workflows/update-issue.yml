name: Notify Author on Status Change
description: Automatically notify author on issues changes
on:
  issues:
    types: [labeled, unlabeled, edited, opened, reopened]
  projects_v2_item:
    types: [edited]
  workflow_dispatch:
jobs:
  check-and-notify:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      # If needed for Projects v2, replace with a PAT:
      # id-token: write
      # pull-requests: read
    steps:
      - name: Check project status and notify
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # or PROJECT_ACCESS_TOKEN if needed
          script: |
            // Handle both issue events and project_v2_item events
            let issue, issueNumber, repo;
            
            if (context.payload.issue) {
              // Direct issue event
              issue = context.payload.issue;
              issueNumber = issue.number;
              repo = context.repo;
            } else if (context.payload.projects_v2_item && context.payload.projects_v2_item.content_type === 'Issue') {
              // Project item event - need to get issue details
              const contentNodeId = context.payload.projects_v2_item.content_node_id;
              
              // Get issue details from node ID
              const issueQuery = `
                query($nodeId: ID!) {
                  node(id: $nodeId) {
                    ... on Issue {
                      number
                      author: user {
                        login
                      }
                      repository {
                        owner {
                          login
                        }
                        name
                      }
                    }
                  }
                }
              `;
              
              const issueResult = await github.graphql(issueQuery, { nodeId: contentNodeId });
              
              if (!issueResult.node) {
                console.log('Could not find issue from project item');
                return;
              }
              
              issueNumber = issueResult.node.number;
              repo = {
                owner: issueResult.node.repository.owner.login,
                repo: issueResult.node.repository.name
              };
              
              // Get full issue details
              const fullIssue = await github.rest.issues.get({
                owner: repo.owner,
                repo: repo.repo,
                issue_number: issueNumber,
              });
              issue = fullIssue.data;
            } else {
              console.log('No valid issue found in payload');
              return;
            }

            if (!issue) {
              console.log('No issue found in payload');
              return;
            }

            const author = issue.user.login;

            console.log(`Processing issue #${issueNumber} by @${author}`);
            console.log(`Repository: ${repo.owner}/${repo.repo}`);
            console.log(`Event type: ${context.eventName}`);

            // For project_v2_item events, check if status field was changed
            let statusChanged = false;
            let previousStatus = null;
            let currentStatus = null;
            
            if (context.eventName === 'projects_v2_item' && context.payload.changes) {
              console.log('Project item changed:', JSON.stringify(context.payload.changes, null, 2));
              
              // Check if any field changes involve status
              for (const [fieldId, change] of Object.entries(context.payload.changes)) {
                if (change.field_type === 'single_select' && change.field_name === 'Status') {
                  statusChanged = true;
                  previousStatus = change.from ? change.from.name : null;
                  currentStatus = change.to ? change.to.name : null;
                  console.log(`Status changed from "${previousStatus}" to "${currentStatus}"`);
                  break;
                }
              }
            }

            const query = `
              query($owner: String!, $name: String!, $issueNumber: Int!) {
                repository(owner: $owner, name: $name) {
                  issue(number: $issueNumber) {
                    projectItems(first: 20) {
                      nodes {
                        id
                        project {
                          title
                          number
                        }
                        fieldValues(first: 20) {
                          nodes {
                            ... on ProjectV2ItemFieldSingleSelectValue {
                              name
                              field {
                                ... on ProjectV2FieldCommon {
                                  name
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            const variables = {
              owner: repo.owner,
              name: repo.repo,
              issueNumber,
            };

            try {
              const result = await github.graphql(query, variables);
              console.log('=== FULL GRAPHQL RESPONSE ===');
              console.log(JSON.stringify(result, null, 2));
              console.log('=== END RESPONSE ===');

              const projectItems = result.repository.issue.projectItems.nodes;
              console.log(`Found ${projectItems.length} project items`);

              if (projectItems.length === 0) {
                console.log('‚ö†Ô∏è No project items found for this issue.');
                return;
              }

              for (const item of projectItems) {
                console.log('');
                console.log(`--- Checking project: ${item.project.title} (Number: ${item.project.number}) ---`);

                if (item.project.number !== 4) {
                  console.log(`‚è≠Ô∏è Skipping project ${item.project.number} (not target project #4)`);
                  continue;
                }

                console.log('‚úÖ This is the target project (#4)');

                for (const fieldValue of item.fieldValues.nodes) {
                  if (fieldValue.field && fieldValue.field.name === 'Status') {
                    const status = fieldValue.name;
                    console.log(`üìä Current status: "${status}"`);

                    // If we detected a status change from project_v2_item event, use that info
                    if (statusChanged && currentStatus) {
                      console.log(`üîÑ Confirmed status change: "${previousStatus}" ‚Üí "${currentStatus}"`);
                    }

                    // Determine if we should post a notification
                    let shouldNotify = false;
                    let notificationReason = '';

                    if (statusChanged) {
                      // Always notify on actual status changes
                      shouldNotify = true;
                      notificationReason = 'status changed';
                    } else {
                      // For other events, check if we haven't notified about this status yet
                      const comments = await github.rest.issues.listComments({
                        owner: repo.owner,
                        repo: repo.repo,
                        issue_number: issueNumber,
                      });

                      const statusNotificationPattern = new RegExp(`status.*updated to.*\\*\\*${status}\\*\\*`, 'i');
                      const alreadyNotified = comments.data.some(comment => {
                        const isBot = comment.user.type === 'Bot';
                        const matchesPattern = statusNotificationPattern.test(comment.body || '');
                        return isBot && matchesPattern;
                      });

                      if (!alreadyNotified) {
                        shouldNotify = true;
                        notificationReason = 'first time notification for this status';
                      } else {
                        notificationReason = 'already notified about this status';
                      }
                    }

                    console.log(`üìù Should notify: ${shouldNotify} (${notificationReason})`);

                    if (shouldNotify) {
                      let notificationBody = '';

                      if (statusChanged && previousStatus) {
                        notificationBody = `üëã @${author}, the status of this issue has been changed from **${previousStatus}** to **${status}**.`;
                      } else {
                        notificationBody = `üëã @${author}, the status of this issue has been updated to **${status}**.`;
                      }

                      // Add specific actions based on status
                      if (status.toLowerCase() === 'in review') {
                        notificationBody += `

### üìã Action Required

**Task:** Please review the implemented fix and provide your feedback.

- [ ] Review the changes
- [ ] Test the implementation
- [ ] Confirm whether the issue is resolved`;
                      } else if (status.toLowerCase() === 'in progress' || status.toLowerCase() === 'in-progress') {
                        notificationBody += `

### üöÄ Work Started

Your issue is now being worked on. You'll be notified when it's ready for review.`;
                      } else if (status.toLowerCase() === 'done' || status.toLowerCase() === 'completed') {
                        notificationBody += `

### üéâ Issue Completed

Thank you for reporting this issue! The fix has been implemented and is now complete.`;
                      } else if (status.toLowerCase() === 'blocked') {
                        notificationBody += `

### ‚ö†Ô∏è Issue Blocked

This issue is currently blocked and may require additional information or dependencies to be resolved.`;
                      }

                      await github.rest.issues.createComment({
                        owner: repo.owner,
                        repo: repo.repo,
                        issue_number: issueNumber,
                        body: notificationBody,
                      });

                      console.log('‚úÖ Notification comment posted successfully');
                    } else {
                      console.log(`‚ÑπÔ∏è Skipping notification - ${notificationReason}`);
                    }

                    break;
                  }
                }
              }

              console.log('');
              console.log('=== Workflow completed successfully ===');
            } catch (error) {
              console.error('‚ùå Error querying project data:');
              console.error('Error name:', error.name);
              console.error('Error message:', error.message);
              if (error.errors) {
                console.error('GraphQL errors:', JSON.stringify(error.errors, null, 2));
              }
              throw error;
            }
